# Copyright 2014 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This set of functions define the interactions with the catkin_tools metadata
# file, `.catkin_tools.yml`. This file can be used by each verb to store
# verb-specific information

from __future__ import print_function

import os
import shutil
import yaml

METADATA_DIR_NAME = '.catkin_tools'

METADATA_README_TEXT = """\
# Catkin Tools Metadata

This directory was generated by catkin_tools and it contains persistent
configuration information used by the `catkin` command and its sub-commands.

Each subdirectory contains a set of persistent configuration options for
separate "profiles." The default profile is called `default`. If another
profile is desired, it can be described in the `profiles.yml` file in this
directory.

Please see the catkin_tools documentation before editing any files in this
directory. Most actions can be perfomred with the `catkin` command-line
program.
"""

PROFILES_YML_FILE_NAME = 'profiles.yml'

DEFAULT_PROFILE_NAME = 'default'


def init_profile(workspace_path, profile_name, reset=False):
    """Initialize a profile directory"""

    (profile_path, _) = get_paths(workspace_path, profile_name)

    # Check if a profile directory already exists
    if os.path.exists(profile_path):
        # Reset the directory if requested
        if reset:
            print("Deleting existing profile from catkin_tools profile profile directory: %s" % (profile_path))
            shutil.rmtree(profile_path)
            os.mkdir(profile_path)
    else:
        # Create a new .catkin_tools directory
        os.mkdir(profile_path)


def get_profile_names(workspace_path):
    """Get a list of profile names available to a given workspace."""

    metadata_root_path = get_metadata_root_path(workspace_path)

    if os.path.exists(metadata_root_path):
        directories = os.walk(metadata_root_path).next()[1]

    return directories


def remove_profile(workspace_path, profile_name):
    """Remove a profile by name."""

    (profile_path, _) = get_paths(workspace_path, profile_name)

    if os.path.exists(profile_path):
        shutil.rmtree(profile_path)


def set_active_profile(workspace_path, profile_name):
    """Set a profile in a given workspace to be active."""

    profiles_data = get_profiles_data(workspace_path)
    profiles_data['active'] = profile_name

    metadata_root_path = get_metadata_root_path(workspace_path)
    profiles_yml_file_path = os.path.join(metadata_root_path, PROFILES_YML_FILE_NAME)
    with open(profiles_yml_file_path, 'w') as profiles_file:
        yaml.dump(profiles_data, profiles_file, default_flow_style=False)


def get_active_profile(workspace_path):
    """Get the active profile name from a workspace path."""

    profiles_data = get_profiles_data(workspace_path)
    if 'active' in profiles_data:
        return profiles_data['active']

    return DEFAULT_PROFILE_NAME


def get_profiles_data(workspace_path):
    """Get the contents of the profiles file.

    This file contains information such as the currently active profile.
    """

    metadata_root_path = get_metadata_root_path(workspace_path)
    profiles_yml_file_path = os.path.join(metadata_root_path, PROFILES_YML_FILE_NAME)
    if os.path.exists(profiles_yml_file_path):
        with open(profiles_yml_file_path, 'r') as profiles_file:
            return yaml.load(profiles_file)

    return {}


def get_metadata_root_path(workspace_path):
    """Get the path to a root metadata directory."""
    return os.path.join(workspace_path, METADATA_DIR_NAME)


def get_paths(workspace_path, profile_name, verb=None):
    """Get the path to a metadata directory and verb-specific metadata file.

    Note: these paths are not guaranteed to exist. This function simply serves
    to standardize where these files should be located.

    :workspace_path: The path to the root of a catkin workspace
    :profile_name: The catkin_tools metadata profile name
    :verb: (optional) The catkin_tools verb with which this information is associated.

    :returns: A tuple of the metadata directory and the verb-specific file path, if given
    """

    # Get the root of the metadata directory
    metadata_root_path = get_metadata_root_path(workspace_path)

    # Get the active profile directory
    metadata_path = os.path.join(metadata_root_path, profile_name) if profile_name else None

    # Get the metadata for this verb
    metadata_file_path = os.path.join(metadata_path, '%s.yml' % verb) if profile_name and verb else None

    return (metadata_path, metadata_file_path)


def find_enclosing_workspace(search_start_path):
    """Find a catkin workspace based on the existence of a catkin_tools
    metadata directory starting in the path given by search_path and traversing
    each parent directory until either finding such a directory or getting to
    the root of the filesystem.

    :search_start_path: Directory which either is a catkin workspace or is
    contained in a catkin workspace

    :returns: Path to the workspace if found, `None` if not found.
    """
    while True:
        # Check if marker file exists
        candidate_path = get_metadata_root_path(search_start_path)
        if os.path.exists(candidate_path) and os.path.isdir(candidate_path):
            return search_start_path

        # Update search path or end
        (search_start_path, child_path) = os.path.split(search_start_path)
        if len(child_path) == 0:
            break

    return None


def init_metadata_root(workspace_path, reset=False):
    """Create or reset a catkin_tools metadata directory with no content in a given path.

    :workspace_path: The path to the root of a catkin workspace
    :reset: If true, clear the metadata directory of all information
    """

    # Make sure the directory
    if not os.path.exists(workspace_path):
        raise IOError(
            "Can't initialize Catkin workspace in path %s because it does "
            "not exist." % (workspace_path))

    # Check if the desired workspace is enclosed in another workspace
    marked_workspace = find_enclosing_workspace(workspace_path)

    if marked_workspace and marked_workspace != workspace_path:
        raise IOError(
            "Can't initialize Catkin workspace in path %s because it is "
            "already contained in another workspace: %s." %
            (workspace_path, marked_workspace))

    # Construct the full path to the metadata directory
    metadata_root_path = get_metadata_root_path(workspace_path)

    # Check if a metadata directory already exists
    if os.path.exists(metadata_root_path):
        # Reset the directory if requested
        if reset:
            print("Deleting existing metadata from catkin_tools metadata directory: %s" % (metadata_root_path))
            shutil.rmtree(metadata_root_path)
            os.mkdir(metadata_root_path)
    else:
        # Create a new .catkin_tools directory
        os.mkdir(metadata_root_path)

    # Write the README file describing the directory
    with open(os.path.join(metadata_root_path, 'README'), 'w') as metadata_readme:
        metadata_readme.write(METADATA_README_TEXT)


def get_metadata(workspace_path, verb):
    """Get a python structure representing the metadata for a given verb.

    :workspace_path: The path to the root of a catkin workspace
    :verb: The catkin_tools verb with which this information is associated

    :returns: A python structure representing the YAML file contents (empty
    dict if the file does not exist)
    """

    active_profile = get_active_profile(workspace_path)
    (metadata_path, metadata_file_path) = get_paths(workspace_path, active_profile, verb)

    if not os.path.exists(metadata_file_path):
        return {}

    with open(metadata_file_path, 'r') as metadata_file:
        return yaml.load(metadata_file)


def update_metadata(workspace_path, verb, new_data={}):
    """Update the catkin_tools metadata file corresponding to a given verb.

    :workspace_path: The path to the root of a catkin workspace
    :verb: The catkin_tools verb with which this information is associated
    :new_data: A python dictionary or array to write to the metadata file
    """

    active_profile = get_active_profile(workspace_path)
    (metadata_path, metadata_file_path) = get_paths(workspace_path, active_profile, verb)

    # Make sure the metadata directory exists
    init_metadata_root(workspace_path)
    init_profile(workspace_path, active_profile)

    # Get the curent metadata for this verb
    data = get_metadata(metadata_path, verb) or dict()

    # Update the metadata for this verb
    data.update(new_data)
    with open(metadata_file_path, 'w') as metadata_file:
        yaml.dump(data, metadata_file, default_flow_style=False)
